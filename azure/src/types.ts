/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/* eslint-disable @typescript-eslint/no-explicit-any */

import type { Identity } from '@azure/arm-msi';
import type { ResourceGroup } from '@azure/arm-resources';
import type { Location } from '@azure/arm-resources-subscriptions';
import type { StorageAccount } from '@azure/arm-storage';
import type { ServiceClient, ServiceClientOptions } from '@azure/core-client';
import type { PipelineRequestOptions, PipelineResponse } from '@azure/core-rest-pipeline';
import type { Environment } from '@azure/ms-rest-azure-env';
import type { AzExtServiceClientCredentials, AzExtServiceClientCredentialsT2, AzExtTreeItem, IAzureUserInput, IActionContext, IRelatedNameWizardContext, ISubscriptionActionContext, ISubscriptionContext, UIExtensionVariables } from '@microsoft/vscode-azext-utils';

export type OpenInPortalOptions = {
    /**
     * A query string applied directly to the host URL, e.g. "feature.staticwebsites=true" (turns on a preview feature)
     */
    queryPrefix?: string;
};

export type AzExtLocation = Location & {
    id: string;
    name: string;
    displayName: string;
}

/**
 * Currently no location-specific properties on the wizard context, but keeping this interface for backwards compatibility and ease of use
 * Instead, use static methods on `LocationListStep` like `getLocation` and `setLocationSubset`
 */
export interface ILocationWizardContext extends ISubscriptionActionContext {
    includeExtendedLocations?: boolean;
}

export interface IResourceGroupWizardContext extends ILocationWizardContext, IRelatedNameWizardContext {
    /**
     * Internal value indicating the last resource group name checked with `ResourceGroupVerifyStep`.
     * This name does not indicate a successful outcome from the verification step, it only indicates that the check has taken place.
     */
    _lastResourceGroupNameVerified?: string;

    /**
     * The resource group to use for new resources.
     * If an existing resource group is picked, this value will be defined after `ResourceGroupListStep.prompt` occurs
     * If a new resource group is picked, this value will be defined after the `execute` phase of the 'create' subwizard
     */
    resourceGroup?: ResourceGroup;

    /**
     * The task used to get existing resource groups.
     * By specifying this in the context, we can ensure that Azure is only queried once for the entire wizard
     */
    resourceGroupsTask?: Promise<ResourceGroup[]>;

    newResourceGroupName?: string;

    /**
     * By default, users will be prompted to select an existing resource group if creating one fails with a 403 error. Set this to `true` to prevent that behavior
     */
    suppress403Handling?: boolean;

    /**
     * Will automatically be generated by UserAssignedIdentityCreateStep if not specified by the user
     */
    newManagedIdentityName?: string;

    /**
     * The managed identity that will be assigned to the resource such as a function app or container app
     * If you need to grant access to a resource, such as a storage account or SQL database, you can use this managed identity to create a role assignment
     * with the RoleAssignmentExecuteStep
     */
    managedIdentity?: Identity;

    ui: IAzureUserInput;
}

export interface IStorageAccountWizardContext extends IResourceGroupWizardContext {
    /**
     * The storage account to use.
     * If an existing storage account is picked, this value will be defined after `StorageAccountListStep.prompt` occurs
     * If a new storage account is picked, this value will be defined after the `execute` phase of the 'create' subwizard
     */
    storageAccount?: StorageAccount;

    newStorageAccountName?: string;
    /**
     * This controls whether the storage account can generate connection strings.
     * This should be disabled for storage accounts that are using managed identity only.
     */
    disableSharedKeyAccess?: boolean;
}

export enum StorageAccountKind {
    Storage = 'Storage',
    StorageV2 = 'StorageV2',
    BlobStorage = 'BlobStorage',
    BlockBlobStorage = 'BlockBlobStorage'
}

export enum StorageAccountPerformance {
    Standard = 'Standard',
    Premium = 'Premium'
}

export enum StorageAccountReplication {
    /**
     * Locally redundant storage
     */
    LRS = 'LRS',

    /**
     * Zone-redundant storage
     */
    ZRS = 'ZRS',

    /**
     * Geo-redundant storage
     */
    GRS = 'GRS',

    /**
     * Read-access geo-redundant storage
     */
    RAGRS = 'RAGRS'
}

export interface INewStorageAccountDefaults {
    kind: StorageAccountKind;
    performance: StorageAccountPerformance;
    replication: StorageAccountReplication;
}

export interface IStorageAccountFilters {
    kind?: StorageAccountKind[];
    performance?: StorageAccountPerformance[];
    replication?: StorageAccountReplication[];

    /**
     * If specified, a 'learn more' option will be displayed to explain why some storage accounts were filtered
     */
    learnMoreLink?: string;
}

export interface IAzureUtilsExtensionVariables extends UIExtensionVariables {
    prefix: string;
}

/**
 * Credential type to be used for creating generic http rest clients
 */
// eslint-disable-next-line @typescript-eslint/no-duplicate-type-constituents
export type AzExtGenericCredentials = AzExtServiceClientCredentials | AzExtServiceClientCredentialsT2;
export type AzExtGenericClientInfo = AzExtGenericCredentials | { credentials: AzExtGenericCredentials; environment: Environment; } | undefined;

export interface IGenericClientOptions {
    noRetryPolicy?: boolean;
    addStatusCodePolicy?: boolean;
    endpoint?: string;
}

export type AzExtRequestPrepareOptions = PipelineRequestOptions & { rejectUnauthorized?: boolean }
export type AzExtPipelineResponse = PipelineResponse & { parsedBody?: any }

export type AzExtClientType<T extends ServiceClient> = new (credentials: AzExtServiceClientCredentials, subscriptionId: string, options?: ServiceClientOptions) => T;

/**
 * Convenience type to give us multiple ways to specify subscription info and action context depending on the scenario
 */
export type AzExtClientContext = ISubscriptionActionContext | [IActionContext, ISubscriptionContext | AzExtTreeItem];

export type AzExtSubscriptionClientType<T> = new (credentials: AzExtServiceClientCredentials, options?: ServiceClientOptions) => T;

export interface ParsedAzureResourceId {
    rawId: string;
    subscriptionId: string;
    resourceGroup: string;
    provider: string;
    resourceName: string;
}

export interface ParsedAzureResourceGroupId {
    rawId: string;
    subscriptionId: string;
    resourceGroup: string;
}
